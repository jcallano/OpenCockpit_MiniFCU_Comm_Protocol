# MiniFCU Interface Reverse Engineering & Emulator
# MiniCockpit Data Link Software Ver 3.0.0 Hardware FirmWare 20251113

This repository documents the serial protocol used by the **miniFCU** autopilot interface (A320 style) and provides a Python emulator that mimics the hardware behavior. 

This project allows developers to:
1. Understand how the proprietary Windows software communicates with the hardware.
2. Build custom drivers for Linux (Raspberry Pi/Orange Pi).
3. Interface the miniFCU with custom flight sim logic without the original bridge software.

## üïµÔ∏è Reverse Engineering Findings

The protocol is **ASCII-based** over a standard USB Serial connection (CH340 chip).

### Connection Settings
* **Baud Rate:** 9600 bps (Critical)
* **Data Bits:** 8, **Parity:** None, **Stop Bits:** 1
* **Signaling:** **DTR and RTS must be set to TRUE** to wake up the microcontroller.

### ü§ù The Handshake (Critical)
The official Windows software will **not** connect unless the device responds correctly to the initialization sequence.



1.  **PC sends:** `C,` (Check/Connect)
2.  **Device MUST respond:** `901;956;959;` (Firmware/Device ID signature)
    * *If this response is missing or incorrect, the software terminates the connection.*

### ‚ù§Ô∏è Keep-Alive & Polling
Once connected, the PC polls the device approximately every 500ms.

1.  **PC sends:** `6,`
2.  **Device responds:** `99;95;...` (Current state of buttons/knobs).

### üìù Data Format

**PC to Device (Display Updates):**
* Terminator: `,` (Comma)
* Format: `[Letter][Value],`

| Command | Function | Example |
| :--- | :--- | :--- |
| `A` | **A**ltitude | `A15000,` (Set Alt to 15000) |
| `S` | **S**peed | `S250,` (Set Spd to 250) |
| `H` | **H**eading | `H120,` (Set Hdg to 120) |
| `V` | **V**ertical Speed | `V1800,` (Set V/S to +1800) |
| `B` | **B**arometer (QNH) | `B1013,` |

**Device to PC (Inputs):**
* Terminator: `;` (Semicolon)
* **Knobs:** `[ID],[Value];` (e.g., `14,101;`)
* **Buttons:** `[ID];` (e.g., `51;` for AP1)

| Input ID | Function | Notes |
| :--- | :--- | :--- |
| `14` | Speed Knob | Value increments/decrements |
| `13` | Heading Knob | Value increments/decrements |
| `17` | Altitude Knob | Value increments/decrements |
| `22` | V/S Knob | Value increments/decrements |
| `51` | AP1 Button | Toggle |
| `50` | A/THR Button | Toggle |
| `54` | LOC Button | Toggle |

---

## üêç Python Emulator

The included script `minifcu_emulator.py` acts as a **Virtual MiniFCU**. It connects to the official Windows Software (via a virtual COM port pair) and tricks it into believing real hardware is attached.

### Usage

1.  **Install dependencies:**
    ```bash
    pip install -r requirements.txt
    ```
2.  **Setup Virtual Serial Ports:**
    * Use software like *com0com* or *Virtual Serial Port Driver*.
    * Create a pair: **COM16** <-> **COM17**.
3.  **Run the Official Software:**
    * Configure it to connect to **COM16**.
4.  **Run the Emulator:**
    ```bash
    python minifcu_emulator.py
    ```
    * The script will attach to **COM17**.

# üìë MiniFCU & EFIS Protocol Cheat Sheet

This document summarizes the serial commands discovered via reverse engineering. It covers both the FCU (Flight Control Unit) and EFIS (Electronic Flight Instrument System) panels.

**Protocol Basics:**
* **Baud Rate:** 9600
* **PC -> Device:** Commands end with `,` (comma).
* **Device -> PC:** Commands end with `;` (semicolon).

---

## üñ•Ô∏è 1. Outputs (PC -> Device)
Commands sent to the device to update displays and LEDs.

### üìü 7-Segment Displays

| Window | Function | Command Syntax | Example | Note |
| :--- | :--- | :--- | :--- | :--- |
| **SPEED** | Write Value | `S` + `[Value]` | `S250` | Range: 0-999 |
| | Dashes | `d` | `d` | Displays `---` |
| | Dot (Managed) | `z` (On) / `x` (Off) | `z` | |
| **HEADING** | Write Value | `H` + `[Value]` | `H180` | Range: 0-359 |
| | Dashes | `h` | `h` | Displays `---` |
| | Dot (Managed) | `m` (On) / `s` (Off) | `m` | |
| **ALTITUDE** | Write Value | `A` + `[Value]` | `A32000` | |
| | Dot (Managed) | *(Logic internal)* | | Managed dot usually handled by logic |
| **VERT SPD** | Write Value | `V` + `[Value]` | `V1500` | Can be negative (e.g., `V-1000`) |
| **FPA** | Write FPA | `F` + `[Value]` | `F-3.0` | Flight Path Angle |
| **QNH** | HectoPascals | `#` + `[Value]` | `#1013` | |
| | Inches Hg | `_` + `[Value]` | `_2992` | |

### üí° LED Annunciators (Korry Buttons)

To turn an LED **ON** or **OFF**, send the corresponding character/code.

| Button | LED ON Command | LED OFF Command |
| :--- | :---: | :---: |
| **AP1** | `P` | `p` |
| **AP2** | `U` | `u` |
| **A/THR** | `T` | `t` |
| **EXPED** | `E` | `e` |
| **APPR** | `R` | `r` |
| **LOC** | *(Not Listed)* | *(Not Listed)* |
| **FD** (EFIS) | `51` | `50` |
| **LS** (EFIS) | `41` | `40` |
| **CSTR** | `31` | `30` |
| **WPT** | `21` | `20` |
| **VOR.D** | `11` | `10` |
| **NDB** | `1` | `0` |
| **ARPT** | `!1` | `!0` |

---

## üéõÔ∏è 2. Inputs (Device -> PC)
Codes received from the hardware when interactions occur. All codes end with `;`.

### üîÑ FCU Rotary Knobs

| Knob Function | Clockwise (CW) | Counter-CW (CCW) | Push | Pull |
| :--- | :---: | :---: | :---: | :---: |
| **SPD / MACH** | `13` | `14` | `11` | `12` |
| **HDG / TRK** | `3` | `4` | `1` | `2` |
| **ALTITUDE** | `17` | `18` | `15` | `16` |
| **VERT SPD** | `21` | `22` | `19` | `20` |
| **BARO (QNH)** | *(Value)* | *(Value)* | `70` (STD) | `69` |

### üîò FCU Push Buttons

| Button Name | Code Received |
| :--- | :---: |
| **AP1** | `50` |
| **AP2** | `51` |
| **A/THR** | `52` |
| **LOC** | `53` |
| **EXPED** | `54` |
| **APPR** | `55` |
| **SPD/MACH Toggle** | `56` |
| **HDG/TRK Toggle** | `57` |
| **METRIC ALT** | `58` |

### üïπÔ∏è EFIS Controls

**ND Mode Selector (Knob)**
| Position | Code |
| :--- | :---: |
| **LS** | `71` |
| **VOR** | `72` |
| **NAV** | `73` |
| **ARC** | `74` |
| **PLAN** | `75` |
| **BLANK** | `76` |

**ND Range Selector (Knob)**
| Position | Code |
| :--- | :---: |
| **10** | `80` |
| **20** | `81` |
| **40** | `82` |
| **80** | `83` |
| **160** | `84` |
| **320** | `85` |

**EFIS Switches & Buttons**
| Control | State/Code |
| :--- | :--- |
| **ADF/VOR 1** | `77` (Off), `78` (ADF), `79` (VOR) |
| **ADF/VOR 2** | `86` (Off), `87` (ADF), `88` (VOR) |
| **CSTR** | `64` |
| **WPT** | `65` |
| **VOR.D** | `66` |
| **NDB** | `67` |
| **ARPT** | `68` |
| **FD** | `62` |
| **LS** | `63` |
| **CHRONO** | `61` |

### ‚öôÔ∏è System / Config Triggers

| Trigger | Code | Description |
| :--- | :---: | :--- |
| **Altitude Step** | `59` | Set increment to 100 |
| **Altitude Step** | `60` | Set increment to 1000 |
| **Baro Mode** | `103` | Set unit to inHg |
| **Baro Mode** | `104` | Set unit to hPa |

### Hardware Implementation (Orange Pi / ESP32)
To implement this on an Orange Pi or custom microcontroller to replace the PC software:
1.  Initialize Serial at 9600 baud.
2.  Send `C,` immediately upon connection.
3.  Send `6,` every 500ms to keep the screen active.
4.  Parse incoming knob data ending in `;`.

## Credits
Reverse engineered using Man-in-the-Middle serial sniffing techniques.
