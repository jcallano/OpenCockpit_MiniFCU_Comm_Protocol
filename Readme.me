MiniFCU Interface Protocol Specification

Version 2.1 – Extended Analysis (Flight-Level Dump)

This document consolidates all currently known information about the MiniFCU / MiniEFIS
communication protocol. It is based on reverse engineering, serial sniffing, and a full
gate-to-gate flight dump including all user interactions.

The focus of this revision is a clear separation between INPUTS (hardware → PC) and
OUTPUTS (PC → hardware), and an explanation of the runtime behavior observed during
active operation versus idle state.

PHYSICAL LAYER

Interface: USB Serial (CH340 chipset)
Baud rate: 9600 bps
Data bits: 8
Parity: None
Stop bits: 1
Flow control: None

IMPORTANT:
DTR and RTS lines must be asserted (TRUE / High) or the MiniFCU microcontroller
will not power up or respond.

PROTOCOL OVERVIEW

Encoding: ASCII text

Delimiter rules:

Hardware → PC frames end with ';'

PC → Hardware frames end with ','

Multiple PC → HW commands are commonly chained into bursts.
Hardware never sends chained commands; each input event is atomic.

Protocol characteristics:

No checksums

No acknowledgments

No error frames

No persistent hardware state

All intelligence resides on the PC side.

COMMUNICATION PHILOSOPHY

The MiniFCU is a stateless, event-driven device.

Principles confirmed by flight-level dumps:

Hardware reports only user actions

Hardware does not track modes or states

PC software continuously refreshes LEDs and displays

PC does not trust previously sent hardware state

During active flight, traffic is dominated by refresh bursts, not by events.

TRAFFIC CLASSES (OBSERVED)

Class A – Input Events (HW → PC)

Triggered only by physical interaction

Single short frame

Immediate transmission

Example: "62;" (EFIS FD button pressed)

Class B – Reactive Bursts (PC → HW)

Triggered after every input event

Multiple commands in sequence

Reassert LEDs, dots, dashes and displays

Class C – Refresh Cycles (PC → HW)

Periodic, even without interaction

Higher frequency during flight

Full state repaint

INPUTS (HARDWARE → PC)

All inputs are event-based.
Each frame ends with ';'.

5.1 Encoders

Speed:

Increment: 13;

Decrement: 14;

Heading:

Increment: 3;

Decrement: 4;

Altitude:

Increment: 17;

Decrement: 18;

Vertical Speed:

Increment: 21;

Decrement: 22;

Barometer / QNH:

Absolute value report: 101,value;

Notes:

Rapid rotation produces bursts of events

No debounce must be applied

Each event represents a physical detent

5.2 Push / Pull Actions

Speed:

Push: 11;

Pull: 12;

Heading:

Push: 1;

Pull: 2;

Altitude:

Push: 15;

Pull: 16;

Vertical Speed:

Push (Level-Off): 19;

5.3 Autopilot Buttons

AP1 : 50;
AP2 : 51;
ATHR : 52;
LOC : 53;
EXPED : 54;
APPR : 55;

5.4 EFIS Buttons

FD : 62;
LS : 63;
CSTR : 64;
WPT : 65;
VORD : 66;
NDB : 67;
ARPT : 68;

OUTPUTS (PC → HARDWARE)

All outputs are commands ending with ','.
They are typically sent in bursts.

6.1 LEDs (Toggle Logic)

Autopilot LEDs:

AP1 : ON = P, OFF = p,

AP2 : ON = U, OFF = u,

ATHR : ON = T, OFF = t,

LOC : ON = L, OFF = l,

EXPED : ON = E, OFF = e,

APPR : ON = R, OFF = r,

EFIS LEDs:

FD : ON = 51, OFF = 50,

LS : ON = 41, OFF = 40,

CSTR : ON = 31, OFF = 30,

WPT : ON = 21, OFF = 20,

VORD : ON = 11, OFF = 10,

NDB : ON = 01, OFF = 00,

ARPT : ON = !1, OFF = !0,

6.2 Displays (7-Segment)

Speed : Sxxx,
Heading : Hxxx,
Altitude : Axxxxx,
Vertical SPD : Vxxxx,
QNH : #xxxx,

6.3 Managed Modes

Speed:

Dot ON : z,

Dot OFF : x,

Dashes : d,

Heading:

Dot ON : m,

Dot OFF : s,

Dashes : h,

Altitude:

Dot ON : a,

Dot OFF : b,

6.4 Undocumented Synchronization Commands

Observed commands:

i,

o,

Behavior:

Sent only PC → HW

No visible hardware effect

No response generated

Appear frequently in bursts

Interpretation:
Internal driver synchronization / buffer keep-alive.
These commands must be preserved when re-implementing the protocol.

ACTIVE FLIGHT OBSERVATIONS

From a full flight dump (takeoff to landing):

Every user event triggers a refresh burst

PC reasserts full state repeatedly

Push + rotate sequences produce longer bursts

QNH encoder sends absolute values only

Hardware never reports state changes, only actions

DESIGN IMPLICATIONS

Recommended architecture:

MiniFCU hardware: event source only

ESP32-S3: transparent Serial ↔ SLIP ↔ JSON bridge

Node-RED / PC software:

Maintains full logical state

Drives LEDs and displays

Publishes state to MQTT

The MiniFCU must be treated as a stateless peripheral.

STATUS

Input protocol: fully reverse engineered
Output protocol: fully usable, synchronization commands required
Remaining unknowns: none observed in full-flight dump

This document represents the current best-known complete specification.
