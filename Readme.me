MiniFCU / MiniEFIS Serial Protocol
Reverse Engineering Documentation by @jcallano
Version: 1.0
Last updated: 2025-Dec
Target aircraft: Airbus A320 (tested with Fenix A320 for MSFS 2020)

DISCLAIMER
----------
This document is the result of my work reverse engineering the protocol to share with the community of sim enthusiast.
It is NOT official documentation and is not affiliated with any hardware
manufacturer or aircraft add-on developer.

Use at your own risk.


============================================================
1. PHYSICAL LAYER & CONNECTION
============================================================

Interface:
- USB Serial (CH340 USB-to-Serial chipset)

Serial Parameters:
- Baud Rate: 9600 bps
- Data Bits: 8
- Parity: None
- Stop Bits: 1
- Flow Control: None (no RTS/CTS, no XON/XOFF)

Critical Power Requirement:
- DTR and RTS lines MUST be asserted HIGH (True)
- If DTR/RTS are not set, the microcontroller does not power up

Notes:
- Only one application can open the COM port at a time (Windows limitation)
- Tested on Windows with pySerial


============================================================
2. PROTOCOL OVERVIEW
============================================================

The protocol is:
- ASCII-based
- Token-oriented
- Event-driven
- Stateless on the hardware side

The MiniFCU / MiniEFIS hardware is NOT intelligent.
It does NOT calculate values or keep logical state.

All logic and authority reside on the PC side.

------------------------------------------------------------
2.1 Message Direction and Delimiters
------------------------------------------------------------

PC → Hardware (Output):
- Each command/token MUST end with a comma ","

Example:
  A32000,

Hardware → PC (Input):
- Each event MUST end with a semicolon ";"

Example:
  17;

Important:
- Bursts may contain multiple tokens/events
- Parsers MUST split by delimiter, not by fixed length


============================================================
3. COMMUNICATION PHILOSOPHY
============================================================

- Hardware reports ONLY physical actions:
  - Button presses
  - Encoder rotations
  - Encoder push/pull
  - QNH absolute values

- Hardware does NOT:
  - Know current values
  - Track managed/selected modes
  - Decide LED states
  - Maintain synchronization

- PC software must:
  - Maintain the full FCU/EFIS state
  - Decide which LEDs are ON/OFF
  - Refresh displays continuously or on change
  - Repaint the panel after power-up or reconnect


============================================================
4. STARTUP SEQUENCE (MANDATORY)
============================================================

After opening the serial port and asserting DTR/RTS,
the following sequence MUST be executed in order.

------------------------------------------------------------
4.1 Handshake Command
------------------------------------------------------------

Command:
  C,

Purpose:
- Wakes up firmware
- Some units respond with firmware IDs (e.g. 901; 956; 959;)
- Some units respond with nothing

IMPORTANT:
- A response is NOT guaranteed
- Software MUST NOT abort if no response is received

------------------------------------------------------------
4.2 Initialization Burst (Limits & Internal State)
------------------------------------------------------------

The following commands MUST be sent after C, :

Q400,
K100,
-99,
+10,
n49000,
b100,
[6000,
]-6000,
Z9900,
X-9900,
I,
Y,
W,
O,
{1,
(3248,
}2200,
=1100,
$745,
%0,

Notes:
- Order matters
- These commands define internal limits and scaling
- Without this burst, encoders and displays may behave incorrectly

------------------------------------------------------------
4.3 Power-Up State Synchronization Burst
------------------------------------------------------------

After initialization, the PC must repaint the entire panel.

Observed reference burst:

#1013,
{1,@1,
51,40,30,20,10,00,!0,
#1013,
Y,
A1000,
i,d,o,h,w,v,x,s,q,
i,d,w,v,
p,u,t,l,e,r,
B1000,
#1013,
{1,@1,
51,40,30,20,10,00,!0,
#1013,

Purpose:
- Synchronize QNH display
- Set EFIS to QNH mode
- Initialize LEDs
- Initialize LCD segments
- Set backlight brightness

Re-sending parts of the burst increases robustness.


============================================================
5. HARDWARE → PC INPUT EVENTS
============================================================

------------------------------------------------------------
5.1 Encoders
------------------------------------------------------------

Speed:
- CW:  13;
- CCW: 14;
- Push: 11;
- Pull: 12;

Heading:
- CW:  3;
- CCW: 4;
- Push: 1;
- Pull: 2;

Altitude:
- CW:  17;
- CCW: 18;
- Push: 15;
- Pull: 16;

Vertical Speed:
- CW:  21;
- CCW: 22;
- Push: 19;
- Push: 20;

------------------------------------------------------------
5.2 Altitude Increment Buttons
------------------------------------------------------------

- 59; → ALT increment = 100 ft
- 60; → ALT increment = 1000 ft

These buttons do NOT control LEDs.
They only change how the PC should interpret ALT encoder steps.

------------------------------------------------------------
5.3 Push Buttons
------------------------------------------------------------

AP1     : 50;
AP2     : 51;
A/THR   : 52;
LOC     : 53;
EXPED   : 54;
APPR    : 55;

EFIS:
FD      : 62;
LS      : 63;
CSTR    : 64;
WPT     : 65;
VOR.D   : 66;
NDB     : 67;
ARPT    : 68;

Buttons are momentary.
PC decides how to interpret them (toggle, hold, etc.).

------------------------------------------------------------
5.4 QNH Encoder
------------------------------------------------------------

Formats:
- 101,value;
- 102,value;

Where "value" is the absolute QNH number.

PC should accept BOTH 101 and 102 as valid QNH sources.


============================================================
6. PC → HARDWARE OUTPUT COMMANDS
============================================================

------------------------------------------------------------
6.1 Displays
------------------------------------------------------------

Speed:
  Sxxx,

Heading:
  Hxxx,

Altitude:
  Axxxxx,

Vertical Speed:
  Vxxxx,

QNH:
  #xxxx,

------------------------------------------------------------
6.2 Managed / Selected Indicators & LCD Segments
------------------------------------------------------------

Observed commands:

z, / x,   → Speed managed dot ON / OFF
m, / s,   → Heading managed dot ON / OFF
a, / b,   → Altitude managed dot ON / OFF
d,        → Speed dashes "---"
h,        → Heading dashes "---"
D,        → Altitude / VS dashes "---"

Other observed segment tokens:
i, o, w, v, x, s, q, Y

Exact semantics may vary by firmware revision.

------------------------------------------------------------
6.3 LEDs
------------------------------------------------------------

Rule:
- Uppercase = LED ON
- Lowercase = LED OFF

Autopilot / FCU LEDs:
P / p  → AP1
U / u  → AP2
T / t  → A/THR
L / l  → LOC
E / e  → EXPED
R / r  → APPR

EFIS LEDs:
51 / 50 → FD
41 / 40 → LS
31 / 30 → CSTR
21 / 20 → WPT
11 / 10 → VOR.D
01 / 00 → NDB
!1 / !0 → ARPT

------------------------------------------------------------
6.4 Backlight
------------------------------------------------------------

Command:
  Bxxxx,

Example:
  B1000,  (maximum brightness)


============================================================
7. IMPLEMENTATION NOTES
============================================================

- Always parse input by delimiter (';')
- Never assume fixed-length messages
- Bursts may contain multiple events
- Hardware does NOT need continuous keep-alive
- Polling is a PC-side design choice only
- Repainting the full panel after reconnect is strongly recommended

============================================================
8. STATUS
============================================================

This protocol has been:
- Observed via serial sniffing
- Validated with real hardware
- Tested with Fenix A320 in MSFS 2020

Contributions, corrections, and confirmations from other developers
are welcome.

END OF DOCUMENT

